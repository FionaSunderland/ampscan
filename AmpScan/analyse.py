# -*- coding: utf-8 -*-
"""
Package for dealing with analysis methods of the ampObject and generating 
reports 
Copyright: Joshua Steer 2019, Joshua.Steer@soton.ac.uk
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as clr
import matplotlib.colorbar as clb
from mpl_toolkits.mplot3d import Axes3D
from collections import defaultdict
from .output import getPDF
from math import floor
#from .cython_ext import planeEdgeIntersect_cy, logEuPath_cy



class analyseMixin(object):
    """
    Analysis methods to act upon a single AmpObject and generate a mpl 
    figure 

    """
           
    def plot_slices(self, axis=2, slWidth=10):
        r"""
        Generate a mpl figure with information about the AmpObject
        
        Top Left - Slices
        Top Right - Change in cross sectional area through slices
        Bottom Left - Rendering of shape
        Bottom Right - Rendering of shape with values 
        
        TODO: Split this up so each figure is it's own function, top level 
        function to tailor figure to user 
        
        Parameters
        ----------
        axis: int, default 2
            Axis along which to take slices
        slWidth: float, default 10
            Distance between slices
        
        Returns
        -------
        fig: mpl figure
            The mpl figure generated by the function
        ax: tuple
            A tuple of axes used for each subplot in the figure

        """
        # Find the brim edges 
        ind = np.where(self.faceEdges[:,1] == -99999)[0]
        # Define max Z from lowest point on brim
        maxZ = self.vert[self.edges[ind, :], 2].min()
        fig = plt.figure()
        fig.set_size_inches(6, 4.5)

        ax1 = fig.add_subplot(221, projection='3d')
        ax2 = fig.add_subplot(222)
        #Z position of slices 
        slices = np.arange(self.vert[:,2].min() + slWidth,
                           maxZ, slWidth)
        polys = self.create_slices(slices, axis)
        PolyArea = np.zeros([len(polys)])
        for i, poly in enumerate(polys):
            ax1.plot(poly[:,0],
                     poly[:,1],
                     poly[:,2],
                     c='b')
            #SlicePolys[i, :] = poly
            # Compute area of slice
            area = 0.5*np.abs(np.dot(poly[:,0], np.roll(poly[:,1], 1)) -
                              np.dot(poly[:,1], np.roll(poly[:,0], 1)))
            PolyArea[i] = area
        extents = np.array([getattr(ax1, 'get_{}lim'.format(dim))() for dim in 'xyz'])
        sz = extents[:,1] - extents[:,0]
        centers = np.mean(extents, axis=1)
        maxsize = max(abs(sz))
        r = maxsize/2
        for ctr, dim in zip(centers, 'xyz'):
            getattr(ax1, 'set_{}lim'.format(dim))(ctr - r, ctr + r)
        ax1.set_axis_off()
        ax2.plot(slices-slices[0], PolyArea)
        # Rendering of the limb scan
        ax3 = fig.add_subplot(2,2,3)
        Im = self.genIm()
        ax3.imshow(Im, None)
        ax3.set_axis_off()
        # Rendering of the rectification map 
        ax4 = fig.add_subplot(2,2,4)
        self.addActor(CMap = self.CMapN2P)
        Im = self.genIm()
        ax4.imshow(Im, None)
        ax4.set_axis_off()
        plt.tight_layout()
        plt.show()
        return fig, (ax1, ax2, ax3, ax4)
        
    def create_slices(self, slices, axis=2):
        """
        Generate polygons from planar slices through the AmpObject 
        
        Parameters
        ----------
        slices: array_like
            The height of the slice planes
        axis: int, default 2
            The index of the axis to take the slices along
        
        Returns
        -------
        polys: list
            A list of numpy arrays, each array contains the vertices of the 
            polygon generated from the slice

        """
        vE = self.vert[:, axis][self.edges]
        # Find all vertices below plane 
        polys = []
        for i, plane in enumerate(slices):
            ind = vE < plane
            # Select edges with one vertex above and one below the slice plane 
            validEdgeInd = np.where(np.logical_xor(ind[:,0], ind[:,1]))[0]
            validfE = self.faceEdges[validEdgeInd, :].astype(int)
            faceOrder = analyseMixin.logEuPath(validfE)
#            g = defaultdict(set)
#            faceOrder = np.zeros(len(validEdgeInd), dtype=int)
#            # Run eularian path algorithm to order faces
#            for v, w in validfE:
#                g[v].add(w)
#                g[w].add(v)
#            v = validfE[0,0]
#            j=0
#            while True:
#                try:
#                    w = g[v].pop()
#                except KeyError:
#                    break
#                g[w].remove(v)
#                faceOrder[j] = v
#                j+=1
#                v = w
            # Get array of three edges attached to each face
            validEdges = self.edgesFace[faceOrder, :]
            # Remove the edge that is not intersected by the plane
            edges = validEdges[np.isin(validEdges, validEdgeInd)].reshape([-1,2])
            # Remove the duplicate edge from order 
            e = edges.flatten()
#            odx = np.argsort(e)
#            inds = np.arange(1, len(e), 2)
#            row = np.unravel_index(odx, e.shape)[0]
#            mask = np.ones(len(e), dtype=bool)
#            mask[row[inds]] = False
#            sortE = e[mask]
            sortE = []
            for ed in e:
                if ed not in sortE:
                    sortE.append(ed)
            sortE.append(sortE[0])
            # Add first edge to end of array
#            sortE = np.append(sortE, sortE[0])
            sortE = np.asarray(sortE)
            polyEdge = self.edges[sortE]
            EdgePoints = np.c_[self.vert[polyEdge[:,0], :], 
                               self.vert[polyEdge[:,1], :]]
            #Create poly from 
            polys.append(analyseMixin.planeEdgeIntersect_cy(EdgePoints, plane, axis))
        return polys
    
    @staticmethod
    def logEuPath(arr):
        vmax = arr.shape[0]
        rows = list(range(vmax))
        order = np.zeros([vmax], dtype=int)
        i = 0
        val = arr[i, 0]
        nmax = vmax-1
        for n in range(nmax):
            del rows[i]
            order[n] = val
            i=0
            xmax = vmax - n + 1
            for x in rows: 
                if arr[x, 0] == val:
                    val = arr[x, 1]
                    break
                if arr[x, 1] == val:
                    val = arr[x, 0]
                    break
                i+=1
        order[n+1] = val
        return order
    
#    def create_slices_cy(self, slices, axis='Z'):
#        """
#        Another method desc.
#        
#        Attributes
#        ----------
#        
#        slices : array
#            Probably not array
#        axis : arg
#            defaults to Z
#
#        """
#        vE = self.vert[:,2][self.edges]
#        # Find all vertices below plane 
#        polys = []
#        for i, plane in enumerate(slices):
#            ind = vE < plane
#            # Select edges with one vertex above and one below the slice plane 
#            validEdgeInd = np.where(np.logical_xor(ind[:,0], ind[:,1]))[0]
#            validfE = self.faceEdges[validEdgeInd, :].astype(int)
#            faceOrder = logEuPath_cy(validfE)
#            #Get array of three edges attached to each face
#            validEdges = self.edgesFace[faceOrder, :]
#            # Remove the edge that is not intersected by the plane
#            edges = validEdges[np.isin(validEdges, validEdgeInd)].reshape([-1,2])
#            # Remove the duplicate edge from order 
#            e = edges.flatten()
#            odx = np.argsort(e)
#            inds = np.arange(1, len(e), 2)
#            row = np.unravel_index(odx, e.shape)[0]
#            mask = np.ones(len(e), dtype=bool)
#            mask[row[inds]] = False
#            sortE = e[mask]
#            # Add first edge to end of array
#            sortE = np.append(sortE, sortE[0])
#            polyEdge = self.edges[sortE]
#            EdgePoints = np.c_[self.vert[polyEdge[:,0], :], 
#                               self.vert[polyEdge[:,1], :]]
#            # Create poly from
##            polys.append(analyseMixin.planeEdgeintersect(EdgePoints, plane, axis=axis))
#            polys.append(planeEdgeIntersect_cy(EdgePoints, plane, 2))
#        return polys
    @staticmethod
    def planeEdgeIntersect_cy(arr, plane, axisInd):
        emax = arr.shape[0]
        intersectPoints = np.zeros((emax, 3), dtype=np.float32)
        intersectPoints[:, axisInd] = plane
        for i in range(emax):
            for j in range(2):
                e1 = arr[i, j]
                e2 = arr[i, axisInd]
                e3 = arr[i, j+3]
                e4 = arr[i, axisInd+3]
                intersectPoints[i, j] = e1 + (plane - e2) * (e3 - e1) / (e4 - e2)
        return intersectPoints
    
    @staticmethod
    def planeEdgeintersect(edges, plane, axis=2):
        r"""
        Calculate the intersection between a an array of edges and a plane
        
        Parameters 
        ----------
        edges: array_like 
            The edge array which have been calculated to cross the plane
        plane: float
            The height of the plane
        axis: int, default 2
            The index of the axis of the slice
        
        Returns
        -------
        intersectPoints: ndarray
            The intersection points between the edges and the plane
        
        """
        # Allocate intersect points array
        intersectPoints = np.zeros((edges.shape[0], 3))
        # Define the plane of intersect points
        intersectPoints[:, axis] = plane
        axesInd = np.array([0,1,2])[np.array([0,1,2]) != axis]
        for i in axesInd:
            intersectPoints[:, i] = (edges[:, i] +
                                     (plane - edges[:, axis]) *
                                     (edges[:, i+3] - edges[:, i]) /
                                     (edges[:, axis+3] - edges[:, axis]))
        return intersectPoints

    def MeasurementsOut(self, pos):
        """
        Calculates perimeter of limb/cast at intervals from mid-patella to the
        end of stump
        Takes position of mid-patella (x,y,z) coordinates as input
        Also creates images of limb views and graphs of CSA/Widths, which are
        used in the PDF.
        Calls the function responsible for adding the information to the PDF
        template.
        TODO: Split this into functions for each part i.e. Volume measure, CSA,
        widths

        Returns
        -------
        The path to the output file
        """
        # print(pos)
        maxZ = []
        for i in [0,1,2]:
            maxZ.append((self.vert[:, i]).max() - (self.vert[:, i]).min())
        #slice in longest axis of scan
        self.axis = maxZ.index(max(maxZ))
        maxZ = max(maxZ)
        zval = pos[self.axis]
        # Get 6 equally spaced pts between mid-patella and stump end
        slices = np.linspace(zval, (self.vert[:,self.axis]).min()+0.1, 6)
        # uses create_slices
        polys = self.create_slices(slices, axis=self.axis)
        # calc perimeter of slices
        perimeter = np.zeros([len(polys)])
        for i,poly in enumerate(polys):
            nverts = np.arange(len(poly)-1)
            dists = []
            for x in nverts:
                xc = (poly[x][0] - poly[x+1][0])**2
                yc = (poly[x][1] - poly[x+1][1])**2
                zc = (poly[x][2] - poly[x+1][2])**2
                dist = np.sqrt(xc+yc+zc)
                dists.append(dist)
            perimeter[i] = sum(dists) / 10
        # distance between slice and mid-patella
        lngth = (slices - zval) / 10
        #print(lngth, perimeter)
        #generate png files of anterior and lateral views
        self.genIm(out='fh',fh='lat.png',az=-90)
        self.genIm(mag=1,out='fh',fh='ant.png')
        #calculations at %length intervals of 10%
        L = maxZ - ((self.vert[:,self.axis]).max()-zval)-10
        pL = np.linspace(0,1.2,13)
        slices2 = []
        for i in pL:
            slices2.append((self.vert[:,self.axis]).min()+10+(i*L))
        polys2 = self.create_slices(slices2,self.axis)
        PolyArea = np.zeros([len(polys2)])
        MLWidth = np.zeros([len(polys2)])
        APWidth = np.zeros([len(polys2)])
        for i, poly in enumerate(polys2):
            # Compute area of slice
            area = 0.5*np.abs(np.dot(poly[:,0], np.roll(poly[:,1], 1)) -
                              np.dot(poly[:,1], np.roll(poly[:,0], 1)))
            PolyArea[i] = area/100
            APW = poly[:,0].max() - poly[:,0].min()
            APWidth[i] = APW/10
            MLW = poly[:,1].max() - poly[:,1].min()
            MLWidth[i] = MLW/10
        # print(PolyArea, MLWidth, APWidth)
        fig = plt.figure()
        fig.set_size_inches(7.5, 4.5)
        ax = fig.add_subplot(221)
        ax.plot(pL*100, PolyArea)
        ax.set_xlabel("% length")
        ax.set_ylabel("Area (cm^2)")
        ax2 = fig.add_subplot(222)
        ax2.plot(pL*100, MLWidth, 'ro',label='Medial-Lateral')
        ax2.plot(pL*100, APWidth, 'b.',label='Anterior-Posterior')
        ax2.set_xlabel("% length")
        ax2.set_ylabel("width (cm)")
        ax2.legend()
        fig.savefig("figure.png")
        return getPDF(lngth, perimeter, PolyArea, APWidth, MLWidth)  # PDF Creation function (in output.py)
        # Divided by 10 to convert to cms, assumes stl files are in mm
        # TODO: Some sort of metric conversion function?


    def CMapOut(self, colors):
        """
        Colour Map with 4 views (copied Josh's code)
        """
        titles = ['Anterior', 'Medial', 'Proximal', 'Lateral']
        fig,axes = plt.subplots(ncols=5)
        cmap = clr.ListedColormap(colors, name='Amp')
        norm = clr.Normalize(vmin=-10,vmax=10)
        cb1 = clb.ColorbarBase(axes[-1], cmap=cmap,norm=norm)
        cb1.set_label('Shape deviation / mm')
        for i, ax in enumerate(axes[:-1]):
            im = self.genIm(size=[3200, 8000],crop=True, az = i*90)
            ax.imshow(im)
            ax.set_title(titles[i])
            ax.set_axis_off()
        #plt.colorbar(CMap)
        fig.set_size_inches([12.5, 4])
        plt.savefig("Limb Views.png", dpi=600)


    def volumeMeasure(self, zval, axis=2, slWidth=0.1):
        """
        volume estimation using slices
        """
        ind = [0,1,2]
        ind.remove(axis)
        slices = np.arange((self.vert[:,axis]).min()+slWidth, zval, slWidth)
        polys = self.create_slices(slices, axis)
        PArea = np.zeros(len(polys))
        for i, poly in enumerate(polys):
            # Compute area of slice
            area = 0.5*np.abs(np.dot(poly[:,ind[0]], np.roll(poly[:,ind[1]], 1)) -
                              np.dot(poly[:,ind[1]], np.roll(poly[:,ind[0]], 1)))
            PArea[i] = area/100
        return sum(PArea*slWidth/10)+(PArea[-1]*(zval-slices[-1]))
        
    
    def CSAMeasure(self,zval, axis=2, interval = 0.05):
        """
        Measure CSA at 5% increments (0-95%) from selected point to stump
        """
        ind = [0,1,2]
        ind.remove(axis)
        percents = np.arange(0.0,0.955,interval)
        distump = (zval-(self.vert[:,axis]).min())
        slices = []
        [slices.append(zval - (distump*i)) for i in percents]
        PArea = np.zeros(len(slices))
        for i,j in enumerate(slices):
            try:
                polys = self.create_slices([j], axis)
                poly = polys[0]
                area = 0.5*np.abs(np.dot(poly[:,ind[0]], np.roll(poly[:,ind[1]], 1)) -
                                  np.dot(poly[:,ind[1]], np.roll(poly[:,ind[0]], 1)))
                PArea[i] = area/100
            except IndexError:
                PArea[i] = None
        return PArea, distump
    
    def widthsMeasure(self,zval,axis=2,interval=0.05):
        """
        Measure Coronal and Sagittal widths at intervals along limb (0-95%)
        """
        percents = np.arange(0.0,0.955,interval)
        distump = (zval-(self.vert[:,axis]).min())
        slices = []
        [slices.append(zval - (distump*i)) for i in percents]
        MLWidth = np.zeros([len(slices)])
        APWidth = np.zeros([len(slices)])
        for i,j in enumerate(slices):
            try:
                polys = self.create_slices([j], axis)
                poly = polys[0]
                APW = poly[:,0].max() - poly[:,0].min()
                APWidth[i] = APW
                MLW = poly[:,1].max() - poly[:,1].min()
                MLWidth[i] = MLW
            except IndexError:
                MLWidth[i] = None
                APWidth[i] = None
        return APWidth, MLWidth
    
    def perimeterMeasure(self,zval,axis=2,interval=0.05):
        """
        Measure Coronal and Sagittal widths at intervals along limb (0-95%)
        """
        percents = np.arange(0.0,0.955,interval)
        distump = (zval-(self.vert[:,axis]).min())
        slices = []
        [slices.append(zval - (distump*i)) for i in percents]
        perimeter = np.zeros([len(slices)])
        for i,j in enumerate(slices):
            try:
                polys = self.create_slices([j], axis)
                poly = polys[0]
                nverts = np.arange(len(poly)-1)
                dists = []
                for x in nverts:
                    xc = (poly[x][0] - poly[x+1][0])**2
                    yc = (poly[x][1] - poly[x+1][1])**2
                    zc = (poly[x][2] - poly[x+1][2])**2
                    dist = np.sqrt(xc+yc+zc)
                    dists.append(dist)
                perimeter[i] = sum(dists) / 10
            except IndexError:
                perimeter[i] = None
        return perimeter, distump